% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/differential_expression.R
\name{np_de_test_cd}
\alias{np_de_test_cd}
\title{Non-parametric differential expression test for count data}
\usage{
np_de_test_cd(
  y,
  labels,
  R = 66,
  log2FC_th = log2(1.2),
  mean_th = 0.05,
  mean_type = "geometric",
  verbosity = 1
)
}
\arguments{
\item{y}{A matrix of counts; must be (or inherit from) class dgCMatrix}

\item{labels}{A factor giving the group labels; must have exactly two levels}

\item{R}{The number of random permutations used to derive the p-values; default is 66}

\item{log2FC_th}{Threshold to remove genes from testing; absolute log2FC must be at least
this large for a gene to be tested; default is \code{log2(1.2)}}

\item{mean_th}{Threshold to remove genes from testing; gene mean must be at least this
large for a gene to be tested; default is 0.05}

\item{mean_type}{Which type of mean to use; if \code{'geometric'} (default) the geometric mean is
used; to avoid \code{log(0)} we use \code{log1p} to add 1 to all counts and log-transform, 
calculate the arithmetic mean, and then back-transform and subtract 1 using \code{exp1m}; if
this parameter is set to \code{'arithmetic'} the data is used as is}

\item{verbosity}{Integer controlling how much messages the function prints; 0 is silent, 1 (default) is not}
}
\value{
Data frame of results
}
\description{
Non-parametric differential expression test for count data
}
\section{Details}{

The observed difference in mean is compared against a distribution
obtained by random shuffling of the group labels. For each gene every 
random permutation yields a difference in mean and from the population of
these background differences we estimate a mean and standard
deviation. This mean and standard deviation are used to turn the observed
difference in mean into a z-score and then into a p-value. Finally,
all p-values (for the tested genes) are adjusted using the Benjamini & Hochberg
method (fdr). The log2FC values in the output are \code{log2(mean1 / mean2)}.
}

\examples{
\donttest{
clustering <- 1:ncol(pbmc) \%\% 2
vst_out <- vst(pbmc, return_corrected_umi = TRUE)
de_res <- np_de_test_cd(y = vst_out$umi_corrected, labels = clustering)
}

}
